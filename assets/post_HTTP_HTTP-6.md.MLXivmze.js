import{_ as i,c as e,o as a,a9 as s}from"./chunks/framework.BPywkn1g.js";const l="/assets/blog-2024-04-16-22-48-13.DhNbv7_T.png",f=JSON.parse('{"title":"HTTP 常见的请求头和响应头","description":"","frontmatter":{"title":"HTTP 常见的请求头和响应头","abbrlink":"5819399a","date":"2024-04-13T16:01:44.000Z","tags":["面试","HTTP"],"categories":[["面试","HTTP"]]},"headers":[],"relativePath":"post/HTTP/HTTP-6.md","filePath":"post/HTTP/HTTP-6.md","lastUpdated":1715773587000}'),t={name:"post/HTTP/HTTP-6.md"},o=s(`<h3 id="http-常见的请求头和响应头与使用场景" tabindex="-1">HTTP 常见的请求头和响应头与使用场景 <a class="header-anchor" href="#http-常见的请求头和响应头与使用场景" aria-label="Permalink to &quot;HTTP 常见的请求头和响应头与使用场景&quot;">​</a></h3><p>写在前面：平常很明显经常使用 HTTP 请求，但具体请求头和响应头了解还是不够。</p><ul><li><a href="#http-常见的请求头和响应头与使用场景">HTTP 常见的请求头和响应头与使用场景</a><ul><li><a href="#什么是http消息头">什么是 http 消息头</a></li><li><a href="#常见请求头">常见请求头</a></li><li><a href="#常见响应头">常见响应头</a></li></ul></li><li><a href="#协商缓存与强缓存">协商缓存与强缓存</a><ul><li><a href="#强缓存">强缓存</a></li><li><a href="#协商缓存">协商缓存</a></li></ul></li></ul><h4 id="什么是-http-消息头" tabindex="-1">什么是 http 消息头 <a class="header-anchor" href="#什么是-http-消息头" aria-label="Permalink to &quot;什么是 http 消息头&quot;">​</a></h4><p>客户端请求（Request）或服务器响应（Response）时传递的，<strong>位请求或响应的第一行</strong>，HTTP 消息体（请求或响应的内容）是其后传输。HTTP 消息头，以明文的字符串格式传送，是以冒号分隔的键/值对，如：Accept-Charset: utf-8，每一个消息头最后以回车符(CR)和换行符(LF)结尾。<br> HTTP 头部字段可以自己根据需要定义，因此可能在 Web 服务器和浏览器上发现非标准的头字段</p><ul><li><p>请求头示例：</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /home.html HTTP/1.1 //请求行，表示这是一个使用 HTTP/1.1 协议的 GET 请求，请求的资源是 /home.html</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> developer.mozilla.org //表示请求的主机名</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">User-Agent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0 //表示发出请求的用户代理的信息，这里是 Firefox 浏览器。</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Accept</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  //表示客户端接受的 MIME 类型, q 参数表示优先级，值越大优先级越高。*/*;q=0.8 表示客户端可以接受任何类型的响应，但优先级较低</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Accept-Language</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> en-US,en;q=0.5 //表示客户端接受的语言</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Accept-Encoding</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> gzip, deflate, br //表示客户端接受的编码方式</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Referer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://developer.mozilla.org/testpage.html //表示发出请求的页面的 URL</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keep-alive //表示连接应保持活动状态，以便进行后续请求</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Upgrade-Insecure-Requests</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1 //表示客户端希望使用更安全的协议进行连接</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">If-Modified-Since</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Mon, 18 Jul 2016 02:36:04 GMT //表示如果自指定日期以来资源已被修改，则获取资源</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">If-None-Match</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;c561c68d0ba92bbeb8b0fff2a9199f722e3a621a&quot; //表示如果 ETag（资源的版本标记）没有改变，则获取资源</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Cache-Control</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> max-age=0 //表示客户端希望获取的是最新的资源，不接受缓存的资源</span></span></code></pre></div></li></ul><h4 id="常见请求头" tabindex="-1">常见请求头 <a class="header-anchor" href="#常见请求头" aria-label="Permalink to &quot;常见请求头&quot;">​</a></h4><ul><li><p><code>Accept</code> : 用来告知服务器，客户端能够处理的媒体类型，可以包含多个媒体类型，用逗号分隔(<code>Accept: text/html</code> ：这表示客户端希望接收 HTML 格式的响应)</p></li><li><p><code>Accept-Charset</code> : 客户端能够理解的字符集。(<code>Accept-Charset:</code> utf-8)</p></li><li><p><code>Accept-Encoding：</code>客户端能够处理的编码方式，如 gzip, deflate</p></li><li><p><code>Accept-Language：</code>客户端的自然语言偏好</p></li><li><p><code>Authorization：</code>用于超文本传输协议的认证的认证信息</p></li><li><p><code>Cache-Control：</code>指定请求和响应遵循的缓存机制</p></li><li><p><code>Connection：</code>表示是否需要持久连接</p></li><li><p><code>Cookie：</code>服务器之前发送的 <code>cookie</code></p></li><li><p><code>Content-Length：</code>请求体的长度</p></li><li><p><code>Content-Type：</code>请求体的 MIME 类型</p></li><li><p><code>Host：</code>请求的服务器的 URL</p></li><li><p><code>If-Modified-Since：</code>如果指定的日期/时间之后资源被修改则获取资源</p></li><li><p><code>If-Match：</code>发送的请求只有在目标资源的当前 ETag 与给定的 ETag 匹配时才会被处理 （用于防止“丢失更新”问题）</p></li><li><p><code>If-None-Match：</code>如果资源的 ETag 没有改变，则获取资源</p></li><li><p><code>Referer：</code>发出请求的页面的地址</p></li><li><p><code>User-Agent：</code>发出请求的用户代理的信息</p></li><li><p><code>Upgrade-Insecure-Requests：</code>提示服务器客户端愿意升级到更安全的连接</p></li></ul><h4 id="常见响应头" tabindex="-1">常见响应头 <a class="header-anchor" href="#常见响应头" aria-label="Permalink to &quot;常见响应头&quot;">​</a></h4><ul><li><p><code>Access-Control-Allow-Origin：</code>指定哪些网站可以进行跨域资源共享</p></li><li><p><code>Access-Control-Allow-Methods：</code>指定允许哪些 HTTP 方法</p></li><li><p><code>Access-Control-Allow-Credentials：</code>指定是否允许发送 Cookie</p></li><li><p><code>Cache-Control：</code>指定请求和响应遵循的缓存机制</p></li><li><p><code>Content-Type：</code>响应体的 MIME 类型</p></li><li><p><code>Content-Length：</code>响应体的长度</p></li><li><p><code>Content-Encoding：</code>响应体的编码方式，如 gzip</p></li><li><p><code>Connection：</code>指定 TCP 连接的类型</p></li><li><p><code>ETag：</code>提供资源的标识值，用于判断资源是否已被修改</p></li><li><p><code>Refresh：</code>用于重定向或在新资源被创建时刷新页面</p></li></ul><h3 id="协商缓存与强缓存" tabindex="-1">协商缓存与强缓存 <a class="header-anchor" href="#协商缓存与强缓存" aria-label="Permalink to &quot;协商缓存与强缓存&quot;">​</a></h3><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><p>强缓存不会向服务器发送请求，直接从缓存中读取资源。<br> 在 Chrome 控制台的 Network 选项中，可以看到该请求的 Size 显示为 from disk cache 或 from memory cache。<br> 强缓存由 HTTP 头信息中的 <code>Expires</code> 和 <code>Cache-Control</code> 两个字段控制</p><ul><li><code>Expires：</code> 这个字段的值是一个日期，表示资源的过期时间。如果请求的时间小于这个时间，浏览器就直接使用缓存的资源，不会向服务器发送请求。但是<code>Expires</code>受到本地时间的影响，如果本地时间被修改，可能会导致缓存失效</li><li><code>Cache-Control：</code> 这个字段的值可以是多个指令，常见的有 max-age、no-cache、no-store、public、private 等。其中 max-age 指定了资源的最大有效时间，单位是秒。如果从缓存中获取资源的时间小于这个时间，浏览器就直接使用缓存的资源，不会向服务器发送请求。Cache-Control 的优先级高于 Expires。</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><p>协商缓存会先向服务器发送请求，询问资源是否有更新。如果没有更新，服务器会返回 304 状态码，告诉浏览器继续使用缓存。 如果有更新，服务器会返回新的资源和 200 状态码。在 Chrome 控制台的 Network 选项中，可以看到该请求的 Size 显示为 304。<br> 协商缓存由 HTTP 头信息中的 <code>Last-Modified/If-Modified-Since</code> 和 <code>ETag/If-None-Match</code> 两对字段控制。</p><ul><li><p><code>Last-Modified/If-Modified-Since：</code> 服务器在返回资源时，会在 HTTP 响应头中添加 <code>Last-Modified</code> 字段，该字段的值表示资源的最后修改时间。当浏览器再次请求这个资源时，会在请求头中添加 <code>If-Modified-Since</code> 字段，其值为上次返回的 <code>Last-Modified</code> 的值。服务器会比较这两个时间，如果相同，说明资源没有变化，服务器会返回 <code>304 Not Modified</code> 状态码，浏览器就直接使用缓存的资源；如果不同，说明资源已经改变，服务器会返回新的资源和 <code>200 OK</code> 状态码。</p></li><li><p><code>ETag/If-None-Match：</code> ETag 是服务器为每个资源生成的一个唯一标识符，当资源发生变化时，ETag 也会改变。服务器在返回资源时，会在 HTTP 响应头中添加 ETag 字段。当浏览器再次请求这个资源时，会在请求头中添加 <code>If-None-Match</code> 字段，其值为上次返回的 ETag 的值。服务器会比较这两个值，如果相同，说明资源没有变化，服务器会返回 <code>304 Not Modified</code> 状态码，浏览器就直接使用缓存的资源；如果不同，说明资源已经改变，服务器会返回新的资源和 <code>200 OK</code> 状态码。</p></li></ul><p><img src="`+l+'" alt="协商缓存示意图"></p>',18),n=[o];function p(c,d,h,r,k,g){return a(),e("div",null,n)}const u=i(t,[["render",p]]);export{f as __pageData,u as default};
