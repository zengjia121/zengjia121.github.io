import{_ as e,c as a,o,a9 as c}from"./chunks/framework.Dq92XQaD.js";const t="/assets/blog-2024-06-09-22-38-29.4CwTbDj-.png",d="/assets/blog-2024-06-09-22-45-35.BqkMDcNH.png",f=JSON.parse('{"title":"地址输入URL敲下回车","description":"","frontmatter":{"title":"地址输入URL敲下回车","tags":["面试","HTTP"],"categories":[["面试","HTTP"]],"date":"2024-06-09T22:36:07.000Z"},"headers":[],"relativePath":"posts/HTTP/HTTP-8.md","filePath":"posts/HTTP/HTTP-8.md","lastUpdated":1718075204000}'),l={name:"posts/HTTP/HTTP-8.md"},r=c('<h1 id="地址栏输入-url-敲下回车后发生了什么" tabindex="-1">地址栏输入 URL 敲下回车后发生了什么? <a class="header-anchor" href="#地址栏输入-url-敲下回车后发生了什么" aria-label="Permalink to &quot;地址栏输入 URL 敲下回车后发生了什么?&quot;">​</a></h1><p>简单来说，发生了以下的行为：</p><ul><li><a href="#地址栏输入-url-敲下回车后发生了什么">地址栏输入 URL 敲下回车后发生了什么?</a><ul><li><a href="#1-url-解析">1. URL 解析</a></li><li><a href="#2-dns-查询">2. DNS 查询</a></li><li><a href="#3-tcp-连接">3. TCP 连接</a></li><li><a href="#4-发送-http-请求">4. 发送 http 请求</a></li><li><a href="#5-响应请求">5. 响应请求</a></li><li><a href="#6-页面渲染">6. 页面渲染</a></li><li><a href="#7-加载资源">7. 加载资源</a></li></ul></li></ul><h2 id="_1-url-解析" tabindex="-1">1. URL 解析 <a class="header-anchor" href="#_1-url-解析" aria-label="Permalink to &quot;1. URL 解析&quot;">​</a></h2><p>首先判断你输入的是一个合法的<code>URL</code>还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p><p><code>URL</code>的解析第过程中的第一步，一个<code>url</code>的结构解析如下： <img src="'+t+'" alt="URL 解析"></p><h2 id="_2-dns-查询" tabindex="-1">2. DNS 查询 <a class="header-anchor" href="#_2-dns-查询" aria-label="Permalink to &quot;2. DNS 查询&quot;">​</a></h2><p>浏览器通过<code>DNS</code>（域名系统）查询将域名转换为服务器的<code>IP</code>地址。这个过程中，浏览器可能会使用缓存的 DNS 记录来加速查询过程，若缓存中无记录，则向本地<code>DNS</code>服务器请求，直至最终获得<code>IP</code>地址。 <img src="'+d+'" alt=" DNS 查询"></p><h2 id="_3-tcp-连接" tabindex="-1">3. TCP 连接 <a class="header-anchor" href="#_3-tcp-连接" aria-label="Permalink to &quot;3. TCP 连接&quot;">​</a></h2><p>一旦获取到服务器的<code>IP</code>地址，浏览器便通过<code>TCP</code>三次握手与服务器建立连接。如果是<code>HTTPS</code>网站，还需进行<code>TLS/SSL</code>握手，以确保数据传输的安全性。</p><h2 id="_4-发送-http-请求" tabindex="-1">4. 发送 http 请求 <a class="header-anchor" href="#_4-发送-http-请求" aria-label="Permalink to &quot;4. 发送 http 请求&quot;">​</a></h2><p>建立连接后，浏览器构造<code>HTTP</code>请求报文，包括请求行（方法、<code>URL</code>、协议版本）、请求头（如 <code>User-Agent</code>、<code>Accept-Language </code>等）和可能的请求体（如<code>POST</code>请求的数据）。然后将这个请求发送给服务器。</p><h2 id="_5-响应请求" tabindex="-1">5. 响应请求 <a class="header-anchor" href="#_5-响应请求" aria-label="Permalink to &quot;5. 响应请求&quot;">​</a></h2><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个 HTTP 响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p><h2 id="_6-页面渲染" tabindex="-1">6. 页面渲染 <a class="header-anchor" href="#_6-页面渲染" aria-label="Permalink to &quot;6. 页面渲染&quot;">​</a></h2><p>浏览器的渲染引擎（如 Chrome 的 Blink、Firefox 的 Gecko）开始解析<code>HTML</code>文档，构建<code>DOM</code>树。同时，<code>CSS</code>样式被解析生成<code>CSSOM</code>树，两者结合形成渲染树。接着计算布局（Layout），确定每个节点在屏幕上的位置和尺寸，最后绘制（Painting）到屏幕上。</p><h2 id="_7-加载资源" tabindex="-1">7. 加载资源 <a class="header-anchor" href="#_7-加载资源" aria-label="Permalink to &quot;7. 加载资源&quot;">​</a></h2><p>页面渲染过程中，浏览器还会解析<code>HTML</code>中的资源引用（如图片、<code>JavaScript</code>、<code>CSS</code> 文件），并发起额外的<code>HTTP</code>请求来获取这些资源。<code>JavaScript</code> 的执行可能阻塞页面渲染，直到脚本执行完毕或使用异步加载技术。</p>',20),i=[r];function h(s,n,p,_,T,u){return o(),a("div",null,i)}const S=e(l,[["render",h]]);export{f as __pageData,S as default};
