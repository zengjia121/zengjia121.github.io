import{_ as t,c as e,o as r,a9 as a}from"./chunks/framework.G_nFLsES.js";const g=JSON.parse('{"title":"设计模式概念","description":"","frontmatter":{"title":"设计模式概念","abbrlink":"8f6fcdfc","date":"2024-03-19T21:18:54.000Z","tags":["笔试","设计模式"],"categories":[["设计模式","简介"]]},"headers":[],"relativePath":"project/设计模式/设计模式-1.md","filePath":"project/设计模式/设计模式-1.md","lastUpdated":1715952728000}'),i={name:"project/设计模式/设计模式-1.md"},l=a('<h1 id="什么是设计模式" tabindex="-1">什么是设计模式 <a class="header-anchor" href="#什么是设计模式" aria-label="Permalink to &quot;什么是设计模式&quot;">​</a></h1><ul><li><a href="#什么是设计模式">什么是设计模式</a><ul><li><a href="#设计模式原则">设计模式原则</a></li><li><a href="#设计模式的类型">设计模式的类型</a></li><li><a href="#参考">参考</a></li></ul></li></ul><p>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计<br> 模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><h2 id="设计模式原则" tabindex="-1">设计模式原则 <a class="header-anchor" href="#设计模式原则" aria-label="Permalink to &quot;设计模式原则&quot;">​</a></h2><ol><li><p>开闭原则（Open Close Principle）</p><p>尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化</p></li><li><p>里氏代换原则（Liskov Substitution Principle）</p><p>使用的基类可以在任何地方使用继承的子类，完美的替换基类。</p></li><li><p>依赖倒转原则（Dependence Inversion Principle）</p><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类</p></li><li><p>接口隔离原则（Interface Segregation Principle）</p><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度</p></li><li><p>迪米特法则，最少知道原则（Demeter Principle）</p><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p></li><li><p>合成复用原则（Composite Reuse Principle）</p><p>尽量使用合成/聚合的方式，而不是使用继承。</p></li></ol><h2 id="设计模式的类型" tabindex="-1">设计模式的类型 <a class="header-anchor" href="#设计模式的类型" aria-label="Permalink to &quot;设计模式的类型&quot;">​</a></h2><p>总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><ul><li><h2 id="创建型模式" tabindex="-1">创建型模式 <a class="header-anchor" href="#创建型模式" aria-label="Permalink to &quot;创建型模式&quot;">​</a></h2><p>提供了一种在<strong>创建对象的同时隐藏创建逻辑的方式</strong>，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li><strong>工厂模式（Factory Pattern）</strong></li><li><strong>抽象工厂模式（Abstract Factory Pattern）</strong></li><li><strong>单例模式（Singleton Pattern）</strong></li><li><strong>建造者模式（Builder Pattern）</strong></li><li><strong>原型模式（Prototype Pattern）</strong></li></ul></li><li><h2 id="结构型模式" tabindex="-1">结构型模式 <a class="header-anchor" href="#结构型模式" aria-label="Permalink to &quot;结构型模式&quot;">​</a></h2><p><strong>关注对象之间的组合和关系</strong>，旨在解决如何构建灵活且可复用的类和对象结构</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li><strong>外观模式（Facade Pattern）</strong></li><li>享元模式（Flyweight Pattern）</li><li><strong>代理模式（Proxy Pattern）</strong></li></ul></li><li><h2 id="行为型模式" tabindex="-1">行为型模式 <a class="header-anchor" href="#行为型模式" aria-label="Permalink to &quot;行为型模式&quot;">​</a></h2><p><strong>关注对象之间的通信和交互</strong>，旨在解决对象之间的责任分配和算法的封装。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li><strong>观察者模式（Observer Pattern）</strong></li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li><strong>策略模式（Strategy Pattern）</strong></li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul></li><li><h2 id="j2ee-模式" tabindex="-1">J2EE 模式 <a class="header-anchor" href="#j2ee-模式" aria-label="Permalink to &quot;J2EE 模式&quot;">​</a></h2><p>这些设计模式特别关注表示层</p><ul><li>MVC 模式（MVC Pattern）</li><li>业务代表模式（Business Delegate Pattern）</li><li>组合实体模式（Composite Entity Pattern）</li><li>数据访问对象模式（Data Access Object Pattern）</li><li>前端控制器模式（Front Controller Pattern）</li><li>拦截过滤器模式（Intercepting Filter Pattern）</li><li>服务定位器模式（Service Locator Pattern）</li><li>传输对象模式（Transfer Object Pattern）</li></ul></li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html" target="_blank" rel="noreferrer">https://www.runoob.com/design-pattern/design-pattern-intro.html</a><a href="https://blog.csdn.net/m0_52184592/article/details/126515200" target="_blank" rel="noreferrer">https://blog.csdn.net/m0_52184592/article/details/126515200</a></p>',10),n=[l];function o(s,p,c,h,d,P){return r(),e("div",null,n)}const _=t(i,[["render",o]]);export{g as __pageData,_ as default};
